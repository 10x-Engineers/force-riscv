#
# Copyright (C) [2020] Futurewei Technologies, Inc.
#
# FORCE-RISCV is licensed under the Apache License, Version 2.0 (the License);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
# FIT FOR A PARTICULAR PURPOSE.
# See the License for the specific language governing permissions and
# limitations under the License.
#
3c3
< #include "sim.h"
---
> #include "simlib.h"
5,6d4
< #include "dts.h"
< #include "remote_bitbang.h"
9d6
< #include <iostream>
17a15,38
> #include "disasm.h"
> 
> // for elf loading
> #include "elf.h"
> #include <sys/stat.h>
> #include <fcntl.h>
> #include <sys/mman.h>
> 
> // for address translation
> #include "memtracer.h"
> 
> //DEBUG
> extern "C" {
> // update_generator_register function: for the given cpuid, this callback function is called by the simulator to notify the user that a register has been accessed.
> //
> //  inputs: 
> //      uint32_t cpuid -- refers to the processor ID
> //      const char* registerName -- the name of the reigster (programmer's name)
> //      uint64_t value -- the data stored in the register after update
> //      uint64_t mask -- 1's indicate relevant bits
> //      const char* accessType -- indicates if the access was a read or write.
> //
> void update_generator_register(uint32_t cpuid, const char* registerName, uint64_t value, uint64_t mask, const char* accessType);  //!< update generator register information when step an instruction
> }
28,43c49,57
< sim_t::sim_t(const char* isa, const char* priv, const char* varch,
<              size_t nprocs, bool halted, bool real_time_clint,
<              reg_t initrd_start, reg_t initrd_end,
<              reg_t start_pc, std::vector<std::pair<reg_t, mem_t*>> mems,
<              std::vector<std::pair<reg_t, abstract_device_t*>> plugin_devices,
<              const std::vector<std::string>& args,
<              std::vector<int> const hartids,
<              const debug_module_config_t &dm_config,
<              const char *log_path)
<   : htif_t(args), mems(mems), plugin_devices(plugin_devices),
<     procs(std::max(nprocs, size_t(1))),
<     initrd_start(initrd_start), initrd_end(initrd_end), start_pc(start_pc),
<     log_file(log_path),
<     current_step(0), current_proc(0), debug(false), histogram_enabled(false),
<     log(false), dtb_enabled(true),
<     remote_bitbang(NULL), debug_module(this, dm_config)
---
> simlib_t::simlib_t(const char* isa, const char* priv, const char* varch, size_t nprocs, bool halted,
>        reg_t start_pc, /*std::vector<std::pair<reg_t, mem_t*>> mems, 
>        std::vector<std::pair<reg_t, abstract_device_t*>> plugin_devices,*/
>        std::vector<int> const hartids)/*,
>        const debug_module_config_t &dm_config)*/
>   : entry(DRAM_BASE), _ForceSparseMemoryModel(Force::EMemBankType::Default),/* mems(mems), plugin_devices(plugin_devices),*/
>     procs(std::max(nprocs, size_t(1))), start_pc(start_pc), current_step(0),
>     current_proc(0), debug(false), histogram_enabled(false), dtb_enabled(true)
>     /*remote_bitbang(NULL), debug_module(this, dm_config)*/
47,54d60
<   for (auto& x : mems)
<     bus.add_device(x.first, x.second);
< 
<   for (auto& x : plugin_devices)
<     bus.add_device(x.first, x.second);
< 
<   debug_module.add_device(&bus);
< 
67,68c73
<     procs[i] = new processor_t(isa, priv, varch, this, hart_id, halted,
<                                log_file.get());
---
>     procs[i] = new processor_t(isa, priv, varch, this, hart_id, halted);
70,72d74
< 
<   clint.reset(new clint_t(procs, CPU_HZ / INSNS_PER_RTC_TICK, real_time_clint));
<   bus.add_device(CLINT_BASE, clint.get());
75c77
< sim_t::~sim_t()
---
> simlib_t::~simlib_t()
82c84
< void sim_thread_main(void* arg)
---
> int simlib_t::step_simulator(int target_id, int num_steps, int stx_failed)
84,85c86,93
<   ((sim_t*)arg)->main();
< }
---
>   procs[target_id]->step(num_steps);
>   procs[target_id]->get_mmu()->yield_load_reservation();
>   const char pc_name[] = "PC\0";
>   const uint64_t pc_mask = 0xFFFFFFFFFFFFFFFF;
>   uint64_t pc_value = 0x0;
>   const char pc_update_access_type[] = "write\0";
>   get_pc_api(target_id, reinterpret_cast<uint8_t*>(&pc_value), pc_name, sizeof(uint64_t));
>   update_generator_register(target_id, pc_name, pc_value, pc_mask, pc_update_access_type);       
87,101c95
< void sim_t::main()
< {
<   if (!debug && log)
<     set_procs_debug(true);
< 
<   while (!done())
<   {
<     if (debug || ctrlc_pressed)
<       interactive();
<     else
<       step(INTERLEAVE);
<     if (remote_bitbang) {
<       remote_bitbang->tick();
<     }
<   }
---
>   return 0; 
104c98
< int sim_t::run()
---
> void simlib_t::set_debug(bool value)
106,108c100
<   host = context_t::current();
<   target.init(sim_thread_main, this);
<   return htif_t::run();
---
>   debug = value;
111c103
< void sim_t::step(size_t n)
---
> int simlib_t::get_disassembly(const uint64_t* pc, char** opcode, char** disassembly)
113c105,109
<   for (size_t i = 0, steps = 0; i < n; i += steps)
---
>   std::string opcode_temp;
>   std::string disassembly_temp;
>   uint64_t opcode_num = 0ull;
> 
>   if(procs.size() > 0)
115,116c111
<     steps = std::min(n - i, INTERLEAVE - current_step);
<     procs[current_proc]->step(steps);
---
>     const disassembler_t* disassembler = procs[0]->get_disassembler(); // should be OK to get processor's disassembler, using it should be idempotent
118,126c113,125
<     current_step += steps;
<     if (current_step == INTERLEAVE)
<     {
<       current_step = 0;
<       procs[current_proc]->get_mmu()->yield_load_reservation();
<       if (++current_proc == procs.size()) {
<         current_proc = 0;
<         clint->increment(INTERLEAVE / INSNS_PER_RTC_TICK);
<       }
---
>     // currently this fails a check in the Spike code if the pc isn't found so the code does not have the opportunity to return 1.
>     insn_fetch_t fetched = procs[0]->get_mmu()->load_insn(*pc); 
>     opcode_num = fetched.insn.bits() & ((1ull << (8 * insn_length(fetched.insn.bits()))) - 1); //This is the conversion the processor_t::disasm(...) uses to format the opcode for output.
>     disassembly_temp = disassembler->disassemble(fetched.insn); 
>     // format the string interpretation of the opcode as a hex number.
>     std::stringstream stream;
>     stream << "0x" << std::hex << opcode_num;
>     opcode_temp = stream.str(); 
>   }
>   else
>   {
>     return 2; // No processors, therefore no configured disassembler for us to use
>   }
128,129c127,130
<       host->switch_to();
<     }
---
>   // At this point disassembly proceeded correctly. Now check the output buffers
>   if(opcode == nullptr || disassembly == nullptr)
>   {
>     return 2;
130a132,146
>   size_t opcode_buffer_length = opcode != nullptr ? strlen(*opcode) : 0;
>   size_t disassembly_buffer_length = disassembly != nullptr ? strlen(*disassembly) : 0;
>   if((opcode_buffer_length < (opcode_temp.size()+1)) || (disassembly_buffer_length < (disassembly_temp.size()+1))) // check for enough size to place the null termination character
>   {
>     return 2; // The user didn't give us room to put the answers
>   }
>   
>   // Warning: the 'insn't' null and string length tests above can fail to uncover a corner case of bad input, where a pointer to a string literal is aliased by a char* pointer. 
>   // The compiler will accept this, but it will fail when you try to copy as in below, basically be sure your string buffer was correctly allocated.
>   opcode_temp.copy(*opcode, opcode_temp.size(), 0);
>   (*opcode)[opcode_temp.size()]='\0'; // No idea how the user is initializing these strings, so just null terminate the relevant part.
>   disassembly_temp.copy(*disassembly, disassembly_temp.size(), 0);
>   (*disassembly)[disassembly_temp.size()]='\0';
> 
>   return 0;
133c149
< void sim_t::set_debug(bool value)
---
> void simlib_t::set_log(bool value)
135c151
<   debug = value;
---
>   log = value;
138c154
< void sim_t::set_histogram(bool value)
---
> void simlib_t::set_histogram(bool value)
146,166c162
< void sim_t::configure_log(bool enable_log, bool enable_commitlog)
< {
<   log = enable_log;
< 
<   if (!enable_commitlog)
<     return;
< 
< #ifndef RISCV_ENABLE_COMMITLOG
<   fputs("Commit logging support has not been properly enabled; "
<         "please re-build the riscv-isa-sim project using "
<         "\"configure --enable-commitlog\".\n",
<         stderr);
<   abort();
< #else
<   for (processor_t *proc : procs) {
<     proc->enable_log_commits();
<   }
< #endif
< }
< 
< void sim_t::set_procs_debug(bool value)
---
> void simlib_t::set_procs_debug(bool value)
172c168
< static bool paddr_ok(reg_t addr)
---
> std::map<std::string, uint64_t> simlib_t::load_elf(const char* fn, reg_t* entry)
174,175c170,238
<   return (addr >> MAX_PADDR_BITS) == 0;
< }
---
>   int fd = open(fn, O_RDONLY);
>   struct stat s;
>   assert(fd != -1);
>   if (fstat(fd, &s) < 0)
>     abort();
>   size_t size = s.st_size;
> 
>   char* buf = (char*)mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
>   assert(buf != MAP_FAILED);
>   close(fd);
> 
>   assert(size >= sizeof(Elf64_Ehdr));
>   const Elf64_Ehdr* eh64 = (const Elf64_Ehdr*)buf;
>   assert(IS_ELF32(*eh64) || IS_ELF64(*eh64));
> 
>   std::vector<uint8_t> zeros;
>   std::vector<uint8_t> attrs;
>   std::map<std::string, uint64_t> symbols;
> 
>   #define LOAD_ELF(ehdr_t, phdr_t, shdr_t, sym_t) do { \
>     ehdr_t* eh = (ehdr_t*)buf; \
>     phdr_t* ph = (phdr_t*)(buf + eh->e_phoff); \
>     *entry = eh->e_entry; \
>     assert(size >= eh->e_phoff + eh->e_phnum*sizeof(*ph)); \
>     for (unsigned i = 0; i < eh->e_phnum; i++) { \
>       if(ph[i].p_type == PT_LOAD && ph[i].p_memsz) { \
>         if (ph[i].p_filesz) { \
>           assert(size >= ph[i].p_offset + ph[i].p_filesz); \
>           attrs.resize(ph[i].p_filesz); \
>           std::fill(attrs.begin(), attrs.end(), 0); \
>           initialize_multiword(ph[i].p_paddr, ph[i].p_filesz, (uint8_t*)buf + ph[i].p_offset); \
>         } \
>         zeros.resize(ph[i].p_memsz - ph[i].p_filesz); \
>         initialize_multiword(ph[i].p_paddr + ph[i].p_filesz, ph[i].p_memsz - ph[i].p_filesz, &zeros[0]); \
>       } \
>     } \
>     shdr_t* sh = (shdr_t*)(buf + eh->e_shoff); \
>     assert(size >= eh->e_shoff + eh->e_shnum*sizeof(*sh)); \
>     assert(eh->e_shstrndx < eh->e_shnum); \
>     assert(size >= sh[eh->e_shstrndx].sh_offset + sh[eh->e_shstrndx].sh_size); \
>     char *shstrtab = buf + sh[eh->e_shstrndx].sh_offset; \
>     unsigned strtabidx = 0, symtabidx = 0; \
>     for (unsigned i = 0; i < eh->e_shnum; i++) { \
>       unsigned max_len = sh[eh->e_shstrndx].sh_size - sh[i].sh_name; \
>       assert(sh[i].sh_name < sh[eh->e_shstrndx].sh_size); \
>       assert(strnlen(shstrtab + sh[i].sh_name, max_len) < max_len); \
>       if (sh[i].sh_type & SHT_NOBITS) continue; \
>       assert(size >= sh[i].sh_offset + sh[i].sh_size); \
>       if (strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) \
>         strtabidx = i; \
>       if (strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) \
>         symtabidx = i; \
>     } \
>     if (strtabidx && symtabidx) { \
>       char* strtab = buf + sh[strtabidx].sh_offset; \
>       sym_t* sym = (sym_t*)(buf + sh[symtabidx].sh_offset); \
>       for (unsigned i = 0; i < sh[symtabidx].sh_size/sizeof(sym_t); i++) { \
>         unsigned max_len = sh[strtabidx].sh_size - sym[i].st_name; \
>         assert(sym[i].st_name < sh[strtabidx].sh_size); \
>         assert(strnlen(strtab + sym[i].st_name, max_len) < max_len); \
>         symbols[strtab + sym[i].st_name] = sym[i].st_value; \
>       } \
>     } \
>   } while(0)
> 
>   if (IS_ELF32(*eh64))
>     LOAD_ELF(Elf32_Ehdr, Elf32_Phdr, Elf32_Shdr, Elf32_Sym);
>   else
>     LOAD_ELF(Elf64_Ehdr, Elf64_Phdr, Elf64_Shdr, Elf64_Sym);
177,188c240,241
< bool sim_t::mmio_load(reg_t addr, size_t len, uint8_t* bytes)
< {
<   if (addr + len < addr || !paddr_ok(addr + len - 1))
<     return false;
<   return bus.load(addr, len, bytes);
< }
< 
< bool sim_t::mmio_store(reg_t addr, size_t len, const uint8_t* bytes)
< {
<   if (addr + len < addr || !paddr_ok(addr + len - 1))
<     return false;
<   return bus.store(addr, len, bytes);
---
>   munmap(buf, size);
>   return symbols;
191c244,245
< void sim_t::make_dtb()
---
> //TODO: Michael use the dedicated function for initializing
> void simlib_t::make_dtb()
196a251,261
>   processor_t* usable_proc_ptr = nullptr;
>   for(uint32_t id = 0; id < 0xffffffffu; ++id)
>   {
>     if(doesCoreWithIdExist(id))
>     {
>       usable_proc_ptr = get_core(id);
>       break;
>     }
>   }
>   assert(usable_proc_ptr != nullptr);
> 
201c266
<     get_core(0)->get_xlen() == 32 ?
---
>     usable_proc_ptr->get_xlen() == 32 ?
214,217d278
<   dts = make_dts(INSNS_PER_RTC_TICK, CPU_HZ, initrd_start, initrd_end, procs, mems);
<   std::string dtb = dts_compile(dts);
< 
<   rom.insert(rom.end(), dtb.begin(), dtb.end());
221,222c282,295
<   boot_rom.reset(new rom_device_t(rom));
<   bus.add_device(DEFAULT_RSTVEC, boot_rom.get());
---
>   //write the rom code to the sparse memory model instead
>   std::vector<char> attrVec(rom.size(), 0x0);
>   for( size_t _index = 0; _index < rom.size(); ++_index)
>   {
>     if(sparse_is_pa_initialized(DEFAULT_RSTVEC + _index, 1))
>     {
>       std::cerr << "### Warning something already initialized the memory for VA: " << std::hex << DEFAULT_RSTVEC + _index << " with contents: " << std::hex << sparse_read(DEFAULT_RSTVEC + _index, 1) << std::endl;
>       sparse_write(DEFAULT_RSTVEC + _index, reinterpret_cast<uint8_t*>(rom.data() + _index), 1);  
>     }
>     else
>     {
>       sparse_initialize_pa(DEFAULT_RSTVEC + _index, reinterpret_cast<const uint8_t*>(rom.data()+_index), reinterpret_cast<const uint8_t*>(attrVec.data()+_index), 1, Force::EMemDataType::Both);
>     }
>   } 
225,232c298,315
< char* sim_t::addr_to_mem(reg_t addr) {
<   if (!paddr_ok(addr))
<     return NULL;
<   auto desc = bus.find_device(addr);
<   if (auto mem = dynamic_cast<mem_t*>(desc.second))
<     if (addr - desc.first < mem->size())
<       return mem->contents() + (addr - desc.first);
<   return NULL;
---
> // Not only loads the elf file in the specified path into the memory model but readies the simulator for stepping. 
> int simlib_t::load_program_now(const char* elfPath)
> {
>   std::string path;
>   if (access(elfPath, F_OK) == 0)
>     path = elfPath;
>  
>   if (path.empty())
>   {
>     std::cerr << "could not open " << elfPath << " (did you misspell it? If VCS, did you forget +permissive/+permissive-off?)" << std::endl;
>     return 1;
>   }
>    
>   std::map<std::string, uint64_t> symbols = load_elf(path.c_str(), &entry);
> 
>   reset();
> 
>   return 0; 
235c318,321
< // htif
---
> uint64_t simlib_t::sparse_read(reg_t paddr, size_t len)
> {
>   return _ForceSparseMemoryModel.Read(paddr, len);
> }
237c323
< void sim_t::reset()
---
> void simlib_t::sparse_read_partially_initialized(reg_t paddr, size_t len, uint8_t* bytes)
239,240c325,340
<   if (dtb_enabled)
<     make_dtb();
---
>   _ForceSparseMemoryModel.ReadPartiallyInitialized(paddr, len, bytes);   
> }
> 
> void simlib_t::sparse_write(reg_t paddr, const uint8_t* bytes, size_t len)
> {
>   _ForceSparseMemoryModel.Write(paddr, bytes, len);    
> }
> 
> void simlib_t::sparse_write(reg_t paddr, uint64_t value, size_t len)
> {
>   _ForceSparseMemoryModel.Write(paddr, value, len);    
> }
> 
> bool simlib_t::sparse_is_pa_initialized(reg_t paddr, size_t len)
> {
>   return  _ForceSparseMemoryModel.IsInitialized(paddr, len);
243c343
< void sim_t::idle()
---
> void simlib_t::sparse_initialize_pa(reg_t paddr, const uint8_t* data, const uint8_t* attrs, uint32_t nBytes, Force::EMemDataType type)
245c345
<   target.switch_to();
---
>   _ForceSparseMemoryModel.Initialize(paddr, data, attrs, nBytes, type);
248c348,382
< void sim_t::read_chunk(addr_t taddr, size_t len, void* dst)
---
> void simlib_t::sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes, Force::EMemDataType type)
> {
>   _ForceSparseMemoryModel.Initialize(paddr, value, numBytes, type);
> }
> 
> void simlib_t::sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes)
> {
>   _ForceSparseMemoryModel.Initialize(paddr, value, numBytes, Force::EMemDataType::Both);
> }
> 
> bool simlib_t::doesCoreWithIdExist(size_t i)
> {
>   for(processor_t* proc_ptr: procs)
>   {
>     if(proc_ptr != nullptr && proc_ptr->get_state() != nullptr && proc_ptr->get_state()->pid == i)
>     {
>       return true;
>     } 
>   }
> 
>   return false;
> }
> 
> void simlib_t::dump_sparse_memory(std::ostream & out)
> {
>   _ForceSparseMemoryModel.Dump(out);
> }
> 
> void simlib_t::reset()
> {
>   if (dtb_enabled)
>     make_dtb();
> }
> 
> void simlib_t::read_chunk_partially_initialized(reg_t taddr, size_t len, void* dst)
251c385
<   auto data = to_le(debug_mmu->load_uint64(taddr));
---
>   auto data = to_le(debug_mmu->load_partially_initialized_uint64(taddr));
255c389,442
< void sim_t::write_chunk(addr_t taddr, size_t len, const void* src)
---
> void simlib_t::clear_chunk(reg_t taddr, size_t len)
> {
>   char zeros[chunk_max_size()];
>   memset(zeros, 0, chunk_max_size());
> 
>   for (size_t pos = 0; pos < len; pos += chunk_max_size())
>     write_chunk(taddr + pos, std::min(len - pos, chunk_max_size()), zeros);
> }
> 
> void simlib_t::initialize_multiword(reg_t addr, size_t len, const void* bytes) // To support multiword initializations during elf loading
> {
>   size_t align = chunk_align();
>   if (len && (addr & (align-1)))
>   { 
>     size_t this_len = std::min(len, align - size_t(addr & (align-1)));
>     uint8_t chunk[align];
>     
>     read_chunk_partially_initialized(addr & ~(align-1), align, chunk);
>     memcpy(chunk + (addr & (align-1)), bytes, this_len);
>     write_chunk(addr & ~(align-1), align, chunk);
>     
>     bytes = (char*)bytes + this_len;
>     addr += this_len;
>     len -= this_len;
>   }
>   
>   if (len & (align-1))
>   { 
>     size_t this_len = len & (align-1);
>     size_t start = len - this_len;
>     uint8_t chunk[align];
>     
>     read_chunk_partially_initialized(addr + start, align, chunk);
>     memcpy(chunk, (char*)bytes + start, this_len);
>     write_chunk(addr + start, align, chunk);
>     
>     len -= this_len;
>   }
>   
>   // now we're aligned
>   bool all_zero = len != 0;
>   for (size_t i = 0; i < len; i++)
>     all_zero &= ((const char*)bytes)[i] == 0;
>   
>   if (all_zero) {
>     clear_chunk(addr, len);
>   } else { 
>     size_t max_chunk = chunk_max_size();
>     for (size_t pos = 0; pos < len; pos += max_chunk)
>       write_chunk(addr + pos, std::min(max_chunk, len - pos), (char*)bytes + pos);
>   }
> }
> 
> void simlib_t::write_chunk(reg_t taddr, size_t len, const void* src)
263c450,455
< void sim_t::proc_reset(unsigned id)
---
> void simlib_t::proc_reset(unsigned id)
> {
> ////  debug_module.proc_reset(id);
> }
> 
> processor_t *simlib_t::get_core(const std::string& i)
265c457,1243
<   debug_module.proc_reset(id);
---
>   char *ptr;
>   unsigned long p = strtoul(i.c_str(), &ptr, 10);
>   //if (*ptr || p >= procs.size())
>   //  throw trap_interactive();
>   return get_core(p);
> }
> 
> reg_t simlib_t::get_mem(const std::vector<std::string>& args)
> {
>   //if(args.size() != 1 && args.size() != 2)
>   //  throw trap_interactive();
> 
>   std::string addr_str = args[0];
>   mmu_t* mmu = debug_mmu;
>   if(args.size() == 2)
>   {
>     processor_t *p = get_core(args[0]);
>     mmu = p->get_mmu();
>     addr_str = args[1];
>   }
> 
>   reg_t addr = strtol(addr_str.c_str(),NULL,16), val; 
>   if(addr == LONG_MAX)
>     addr = strtoul(addr_str.c_str(),NULL,16);
> 
>   switch(addr % 8)
>   {
>     case 0:
>       val = mmu->load_uint64(addr);
>       break;
>     case 4:
>       val = mmu->load_uint32(addr);
>       break;
>     case 2:
>     case 6:
>       val = mmu->load_uint16(addr);
>       break;
>     default:
>       val = mmu->load_uint8(addr);
>       break;
>   }
>   return val;
> }
> 
> uint64_t simlib_t::get_csr_number(const std::string& input_name)
> {
>   //Cant use a switch here unless we map the names to ints beforehand
>   #define DECLARE_CSR(name, number) if (input_name == #name) return number;
>   #include "encoding.h"              // generates if's for all csrs
>   return 0xDEADBEEFDEADBEEF;         // else return a value outside the ISA established 4096 possible
>   #undef DECLARE_CSR
> }
> 
> uint64_t simlib_t::get_xpr_number(const std::string& input_name)
> {
>   return std::find(xpr_arch_name, xpr_arch_name + NXPR, input_name) - xpr_arch_name;
> }
> 
> uint64_t simlib_t::get_fpr_number(const std::string& input_name)
> {
>   return std::find(fpr_arch_name, fpr_arch_name + NFPR, input_name) - fpr_arch_name;
> }
> 
> uint64_t simlib_t::get_vecr_number(const std::string& input_name)
> {
>   return std::find(vr_name, vr_name + NVPR, input_name) - vr_name;
> }
> 
> std::string simlib_t::get_csr_name(uint64_t index)
> {
>   if(index < NCSR)
>     return csr_name(index); 
>   else
>     return "unknown-csr";
> }
> 
> std::string simlib_t::get_xpr_name(uint64_t index)
> {
>   if(index < NXPR)
>     return xpr_arch_name[index];
>   else
>     return "unknown-xpr";
> }
> 
> std::string simlib_t::get_fpr_name(uint64_t index)
> {
>   if(index < NFPR)
>     return fpr_arch_name[index];
>   else
>     return "unknown-fpr";
> }
> 
> std::string simlib_t::get_vecr_name(uint64_t index)
> {
>   if(index < NVPR)
>     return vr_name[index];
>   else
>     return "unknown-vr";
> }
> 
> int simlib_t::read_csr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1; 
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index is valid
>   if(index >= NCSR)
>     return 3;
> 
>   //Check if the index corresponds to a defined csr
>   // WARNING: there are a number of CSRs that are defined in encoding.h but have no entry in the processor class get_csr method. In this case, for now, a value of 0xDEADBEEFDEADBEEF will be returned
>   std::string temp_name = get_csr_name(index);
>   size_t unknown = temp_name.find("unknown");
>   if(unknown != std::string::npos)
>     return 3;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer 
>   *value = get_core(procid)->get_csr_api(index);
>   *length = get_core(procid)->get_xlen() / 8;
> 
>   return 0;
> }
> 
> int simlib_t::read_csr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1; 
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_csr_number(input_name);
>   if(index >= NCSR) 
>     return 3; 
>    
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   *value = get_core(procid)->get_csr_api(index);       
>   *length = get_core(procid)->get_xlen() / 8; 
> 
>   return 0;
> }
> 
> int simlib_t::read_xpr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_xpr_number(input_name);
>   if(index >= NXPR)
>     return 3;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   *value = get_core(procid)->get_state()->XPR.readNoCallback(index);
>   *length = get_core(procid)->get_xlen() / 8;
> 
>   return 0;  
> }
> 
> int simlib_t::read_xpr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the index provided is valid
>   if(index >= NXPR)
>     return 3;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   //*value = get_core(procid)->get_state()->XPR[index];
> 
>   *value = get_core(procid)->get_state()->XPR.readNoCallback(index);
>   *length = get_core(procid)->get_xlen() / 8;
> 
>   return 0;
> }
> 
> int simlib_t::read_fpr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the name provided is valid
>   uint64_t index = get_fpr_number(input_name);
>   if(index >= NFPR)
>     return 3;
> 
>   //Check that the advertised length of the provided buffer is sufficient
>   if(*length < sizeof(freg_t))
>     return 4;
> 
>   //All checks have passed, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   freg_t temp_fpr_val = get_core(procid)->get_state()->FPR.readNoCallback(index);
>   memcpy(value, &temp_fpr_val, sizeof(freg_t));
>   *length = sizeof(freg_t);
> 
>   return 0;  
> }
> 
> int simlib_t::read_fpr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NFPR)
>     return 3;
> 
>   if(*length < sizeof(freg_t))
>     return 4; 
> 
>   //All checks have passed
>   freg_t temp_fpr_val = get_core(procid)->get_state()->FPR.readNoCallback(index);
>   memcpy(value, &temp_fpr_val, sizeof(freg_t));
>   *length = sizeof(freg_t);
> 
>   return 0;  
> }
> 
> int simlib_t::read_vecr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name provided is valid
>   uint64_t index = get_vecr_number(input_name);
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen > *length){
>     return 4; 
>   }
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     uint64_t val = 0ull;
>     switch(elen)
>     {
>       case 8:
>       val = get_core(procid)->VU.elt<uint64_t>(index, element);
>       break;
>       case 4:
>       val = get_core(procid)->VU.elt<uint32_t>(index, element);
>       break;
>       case 2:
>       val = get_core(procid)->VU.elt<uint16_t>(index, element);
>       break;
>       case 1:
>       val = get_core(procid)->VU.elt<uint8_t>(index, element);
>       break;
>     }
> 
>     memcpy(value + element * elen, &val, elen);
>   }
> 
>   //Set the length value to the number of bytes that was written
>   *length = vlen;
> 
>   return 0;
> }
> 
> int simlib_t::read_vecr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen > *length){
>     return 4; 
>   }
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     uint64_t val = 0ull;
>     switch(elen)
>     {
>       case 8:
>       val = get_core(procid)->VU.elt<uint64_t>(index, element);
>       break;
>       case 4:
>       val = get_core(procid)->VU.elt<uint32_t>(index, element);
>       break;
>       case 2:
>       val = get_core(procid)->VU.elt<uint16_t>(index, element);
>       break;
>       case 1:
>       val = get_core(procid)->VU.elt<uint8_t>(index, element);
>       break;
>     }
> 
>     memcpy(value + element * elen, &val, elen);
>   }
> 
>   //Set the length value to the number of bytes that was written
>   *length = vlen;
> 
>   return 0;
> }
> 
> int simlib_t::partial_read_vecr(uint32_t procid, uint64_t index, uint8_t* pValue, uint32_t length, uint32_t offset)
> {
>   //Check that the pointers point to something
>   if(pValue == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen < (offset + length)){
>     return 4; 
>   }
> 
>   //All checks passed; write the elements into the value buffer
>   // TODO make this a memcpy
>   for(size_t element = offset; element < (offset + length); ++element)
>   {
>     pValue[element - offset] = get_core(procid)->VU.elt<uint8_t>(index, element);
>   }
> 
>   return 0;
> }
> 
> 
> int simlib_t::partial_write_vecr(uint32_t procid, uint64_t index, const uint8_t* pValue, uint32_t length, uint32_t offset)
> {
>   //Check that the pointers point to something
>   if(pValue == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen < (offset + length)){
>     return 4; 
>   }
> 
>   //All checks passed; write the elements into the value buffer
>   // TODO make this a memcpy
>   for(size_t element = offset; element < (offset + length); ++element)
>   {
>     get_core(procid)->VU.elt<uint8_t>(index, element) = pValue[element - offset];
>   }
> 
>   return 0;
> }
> 
> 
> int simlib_t::write_csr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1; 
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index is valid
>   if(index >= NCSR)
>     return 3;
> 
>   //Is the indended write length matching the xlen value?
>   if(length != (get_core(procid)->get_xlen() / 8))
>     return 4;
> 
>   //All checks pass, so go ahead and and write to the csr 
>   get_core(procid)->set_csr_api(index, *value);
> 
>   return 0;
> }
> 
> int simlib_t::write_csr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1; 
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_csr_number(input_name);
>   if(index >= NCSR) 
>     return 3; 
> 
>   //Is the indended write length matching the xlen value?
>   if(length != (get_core(procid)->get_xlen() / 8))
>     return 4;
> 
>   //All checks pass, so go ahead and and write to the csr 
>   get_core(procid)->set_csr_api(index, *value);
> 
>   return 0;
> }
> 
> int simlib_t::write_xpr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_xpr_number(input_name);
>   if(index >= NXPR)
>     return 3;
> 
>   //Is the indended write length matching the xlen value?
>   if(length != (get_core(procid)->get_xlen() / 8))
>     return 4;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   get_core(procid)->get_state()->XPR.writeNoCallback(index, *value);
> 
>   return 0;  
> }
> 
> int simlib_t::write_xpr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the index provided is valid
>   if(index >= NXPR)
>     return 3;
> 
>   //Is the indended write length matching the xlen value?
>   if(length != (get_core(procid)->get_xlen() / 8))
>     return 4;
> 
>   //All checks pass so we're go to write
>   get_core(procid)->get_state()->XPR.writeNoCallback(index, *value);
> 
>   return 0;
> }
> 
> int simlib_t::write_fpr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the name provided is valid
>   uint64_t index = get_fpr_number(input_name);
>   if(index >= NFPR)
>     return 3;
> 
>   //Is the indended write length matching the flen value?
>   if(length > sizeof(freg_t))
>     return 4;
> 
>   //All checks have passed perform the write via a memory operation into the floating point register model
>   freg_t temp_fpr_val;
>   temp_fpr_val.v[0] = 0xffffffffffffffffull;
>   temp_fpr_val.v[1] = 0xffffffffffffffffull;
>   memcpy(&temp_fpr_val, value, length);
>   get_core(procid)->get_state()->FPR.writeNoCallback(index, temp_fpr_val);
> 
>   return 0;  
> }
> 
> int simlib_t::write_fpr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NFPR)
>     return 3;
> 
>   //Is the indended write length matching the flen value?
>   if(length > sizeof(freg_t))
>     return 4;
> 
>   //All checks have passed perform the write via a memory operation into the floating point register model
>   freg_t temp_fpr_val;
>   temp_fpr_val.v[0] = 0xffffffffffffffffull;
>   temp_fpr_val.v[1] = 0xffffffffffffffffull;
>   memcpy(&temp_fpr_val, value, length);
>   get_core(procid)->get_state()->FPR.writeNoCallback(index, temp_fpr_val);
> 
>   return 0;  
> }
> 
> //TODO this and beyond, will probably have to cast differently here and other places to the get the pointer types the same and compatible with the function.
> int simlib_t::write_vecr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name provided is valid
>   uint64_t index = get_vecr_number(input_name);
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes equals the size of the vector register 
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen != length)
>     return 4; 
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     switch(elen)
>     {
>       case 8:
>       {
>         uint64_t* reg = &(get_core(procid)->VU.elt<uint64_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 4:
>       {
>         uint32_t* reg = &(get_core(procid)->VU.elt<uint32_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 2:
>       {
>         uint16_t* reg = &(get_core(procid)->VU.elt<uint16_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 1:
>       {
>         uint8_t* reg = &(get_core(procid)->VU.elt<uint8_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>     }
>   }
> 
>   return 0;
> }
> 
> int simlib_t::write_vecr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen != length)
>     return 4; 
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     switch(elen)
>     {
>       case 8:
>       {
>         uint64_t* reg = &(get_core(procid)->VU.elt<uint64_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 4:
>       {
>         uint32_t* reg = &(get_core(procid)->VU.elt<uint32_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 2:
>       {
>         uint16_t* reg = &(get_core(procid)->VU.elt<uint16_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 1:
>       {
>         uint8_t* reg = &(get_core(procid)->VU.elt<uint8_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>     }
>   }
> 
>   return 0;
> }
> 
> int simlib_t::translate_virtual_address_api(int procid, const uint64_t* vaddr, int intent, uint64_t* paddr, uint64_t* memattrs)
> {
>   // check the pointers do point to something
>   if(vaddr == nullptr || paddr == nullptr || memattrs == nullptr)
>     return 1;
> 
>   // Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   // get the mmu for the specified processor and call the translation api function
>   access_type type;
>   switch(intent)
>   {
>     case(0):
>       type = access_type::LOAD;
>       break;
>     case(1):
>       type = access_type::STORE;
>       break;
>     case(2):
>       type = access_type::FETCH;
>       break;
>   }
>   int status = get_core(procid)->get_mmu()->translate_api(*vaddr, paddr, memattrs, reg_t(1) /* length */, static_cast<access_type>(intent)); // length is set to 1 byte here because the api requirements were for individual bytes only.
> 
>   if(status == 0)
>   {
>     return 0;
>   }
>   
>   return status + 2; 
> }
> 
> bool simlib_t::set_pc_api(int procid, const std::string& name, const uint8_t* bytes, size_t len)
> {
>   if(bytes == nullptr)
>   {
>     return false;
>   }
>   else if(not doesCoreWithIdExist(procid))
>   {
>     return false;
>   }
> 
>   processor_t* proc_ptr = get_core(procid);
>   if(proc_ptr == nullptr)
>   {
>     return false;
>   }
> 
>   return get_core(procid)->set_pc_api(name, bytes, len);  
> }
> 
> bool simlib_t::get_pc_api(int procid, uint8_t* bytes, const std::string& name, size_t len)
> {
>   if(bytes == nullptr)
>   {
>     return false;
>   }
>   else if(not doesCoreWithIdExist(procid))
>   {
>     return false;
>   }
> 
>   processor_t* proc_ptr = get_core(procid);
>   if(proc_ptr == nullptr)
>   {
>     return false;
>   }
> 
>   return get_core(procid)->retrieve_pc_api(bytes, name, len); // The method called in processor_t will validate the name and length.  
> }
> 
> bool simlib_t::set_privilege_api(int procid, const uint64_t* val)
> {
>   if (nullptr == val) return false;
>   if (!doesCoreWithIdExist(procid)) return false;
> 
>   processor_t* proc_ptr = get_core(procid);
>   if (nullptr == proc_ptr) return false;
> 
>   //assert in legalize_privilege should catch invalid values
>   //register field is only 2 bits so shouldn't be able to pass invalid case from force
>   proc_ptr->set_privilege_api(*val); 
>   return true;
> }
> 
> bool simlib_t::get_privilege_api(int procid, uint64_t* val)
> {
>   if(nullptr == val) return false;
>   if(!doesCoreWithIdExist(procid)) return false;
> 
>   processor_t* proc_ptr = get_core(procid);
>   if(nullptr == proc_ptr) return false;
> 
>   proc_ptr->retrieve_privilege_api(val);
>   return true;
